// Game Boy WebGL Emulator Skeleton - RJS Full Compact

GB_SCREEN_W :: 160
GB_SCREEN_H :: 144
GB_SCALE    :: 4
GB_CPU_HZ   :: 4194304

:c GBMemory
  :n ()
    :@bytes := :N Uint8Array(0x10000)
    :@joyp  := 0xFF
	:@apu   := :$  
    
    // debug helper
    :@debugIO       := 0
    :@debugIOCount  := 0
    :@debugCpu      := :$ 
    :@debugBG       := 0
    :@debugBGCount  := 0
  :e

  :m attachCpu(cpu)
    :@debugCpu = cpu
  :e

  :m attachApu(apu)
    :@apu = apu
  :e


  :m reset()
    :@bytes.fill(0)
    b := :@bytes
    b[0xFF00] = 0xFF
    b[0xFF40] = 0x91
    b[0xFF42] = 0x00
    b[0xFF43] = 0x00
    b[0xFF47] = 0xFC
  :e

  :m loadRom(romBytes)
    // โหลด ROM ใส่ช่วงต้นของ Memory
    :* (let i = 0; i < romBytes.length; i++)
      :@bytes[i] = romBytes[i]
    :e
  :e

  :m rb(addr)
    a := addr & 0xFFFF
    if (a == 0xFF00)
      :^ :@joyp | 0x0F
    :e
    :^ :@bytes[a]
  :e

  :m wb(addr, val)
    a := addr & 0xFFFF
    v := val & 0xFF

    // --- FIX 1: Protection ---
    // ห้ามเขียนทับ ROM (0x0000-0x7FFF)
    // ยกเว้นกรณีทำ MBC Banking (ซึ่ง Tetris ตัวธรรมดาไม่ต้องใช้)
    if (a < 0x8000) -> :^


    // --- FIX 2: OAM DMA Transfer (0xFF46) ---
    // จำเป็นมาก ไม่งั้น Sprites (แท่งบล็อก) จะไม่ขยับ/ไม่โชว์
    if (a == 0xFF46)
      baseAddr := v << 8
      // Copy 160 bytes (40 sprites * 4 bytes)
      :* (let i = 0; i < 160; i++)
        src := (baseAddr + i) & 0xFFFF
        :@bytes[0xFE00 + i] = :@bytes[src]
      :e
      
      // DMA จริงๆ กินเวลา 160ms แต่ใน emu แบบง่าย ให้จบเลยก็ได้
      // แล้วเขียนค่าลง register ไว้ด้วย
      :@bytes[a] = v
      :^
    :e

    // --- JOYP (FF00) ---
    if (a == 0xFF00)
      :@joyp = (v & 0xF0) | 0x0F
      :@bytes[a] = :@joyp
      :^
    :e
	
    // --- SOUND (FF10-FF3F) → ส่งต่อให้ APU ---
    if (a >= 0xFF10 && a <= 0xFF3F && :@apu)
      :@apu.writeReg(a, v)
      // ตรงนี้ยังให้เขียนค่าเก็บใน bytes ปกติด้วย (ด้านล่าง)
    :e

    // --- IO debug trace ---
    if (a >= 0xFF00 && a <= 0xFFFF && :@debugIO)
      if (:@debugIOCount < 2000)
        pcVal := -1
        if (:@debugCpu)
          pcVal = :@debugCpu.pc
        :e
        console.log("IOWB", "PC=" + pcVal.toString(16), "addr=" + a.toString(16), "val=" + v.toString(16))
        :@debugIOCount = (:@debugIOCount + 1) | 0
      :e
    :e

    // --- BG map debug ---
    if (a >= 0x9800 && a <= 0x9FFF && :@debugBG)
       // ... (debug code เดิม) ...
    :e

    // ถ้าผ่านทุกเงื่อนไข ก็เขียนลง Memory ได้ (RAM/VRAM/IO)
    :@bytes[a] = v
  :e
:e 
//End memory 


:c GBPPU
  :n ()
    :@width  := GB_SCREEN_W
    :@height := GB_SCREEN_H
    :@frameBuffer := :N Uint8Array(GB_SCREEN_W * GB_SCREEN_H * 4)
    :@frameCount  := 0
    :@mem := :$     // จะถูก attach จาก GBEmu
  :e

  :m attachMemory(mem)
    :@mem = mem
  :e

  :m reset()
    :@frameCount = 0
    fb := :@frameBuffer
    size := fb.length
    :* (let i = 0; i < size; i++)
      fb[i] = 0
    :e
  :e

  :m clearScreen(shade)
    fb := :@frameBuffer
    size := :@width * :@height
    :* (let i = 0; i < size; i++)
      j := i * 4
      fb[j]     = shade
      fb[j + 1] = shade
      fb[j + 2] = shade
      fb[j + 3] = 255
    :e
  :e
  
  
  // --- Sprite renderer (DMG only, 8×8 / 8×16) ---
  :m renderSprites()
    mem := :@mem
    fb  := :@frameBuffer
    w   := :@width
    h   := :@height

    if (!mem || !fb) -> :^

    lcdc := mem.rb(0xFF40) & 0xFF

    spriteEnable := (lcdc & 0x02) != 0    // bit1
    spriteTall   := (lcdc & 0x04) != 0    // bit2 (8×16)
    if (!spriteEnable) -> :^

    obp0 := mem.rb(0xFF48) & 0xFF   // OBJ palette 0
    obp1 := mem.rb(0xFF49) & 0xFF   // OBJ palette 1

    // decode DMG obj palette (เหมือน BGP)
    fn shadeFromObj(ci, attr)
      pal1 := (attr & 0x10) != 0
      pal  := pal1 ? obp1 : obp0

      bits  := (pal >> (ci * 2)) & 0x03
      shade := 0
      if (bits == 0)
        shade = 255    // ขาว
      :? if (bits == 1)
        shade = 192
      :? if (bits == 2)
        shade = 96
      :e
        shade = 0      // ดำ
      :^ shade
    :e

    // OAM: 40 sprites × 4 bytes @ FE00
    :* (let i = 0; i < 40; i++)
      oamBase := 0xFE00 + i * 4

      sprY := (mem.rb(oamBase)     & 0xFF) - 16   // GB spec: Y-16
      sprX := (mem.rb(oamBase + 1) & 0xFF) - 8    // GB spec: X-8
      tile :=  mem.rb(oamBase + 2) & 0xFF
      attr :=  mem.rb(oamBase + 3) & 0xFF

      // นอกจอทั้งก้อน → ข้าม
      if (sprX <= -8 || sprX >= w || sprY <= -16 || sprY >= h) -> :e

      xFlip := (attr & 0x20) != 0
      yFlip := (attr & 0x40) != 0
      // bit7 priority / bit0–2 CGB color ยังไม่ใช้

      height    := spriteTall ? 16 : 8
      baseTile  := spriteTall ? (tile & 0xFE) : tile   // 8×16: ignore bit0

      :* (let line = 0; line < height; line++)
        screenY := sprY + line
        if (screenY < 0 || screenY >= h) -> :e

        row := yFlip ? (height - 1 - line) : line
        tileIndex := baseTile + (row >= 8 ? 1 : 0)
        rowY := row & 7

        // sprite ใช้ tile data ที่ 0x8000 เสมอ
        tileAddr := 0x8000 + tileIndex * 16 + rowY * 2

        low  := mem.rb(tileAddr)
        high := mem.rb(tileAddr + 1)

        :* (let col = 0; col < 8; col++)
          screenX := sprX + col
          if (screenX < 0 || screenX >= w) -> :e

          bitIndex := xFlip ? col : (7 - col)

          b0 := (low  >> bitIndex) & 1
          b1 := (high >> bitIndex) & 1
          ci := (b1 << 1) | b0      // 0..3

          // color 0 = โปร่งใส
          if (ci == 0) -> :e

          shade := shadeFromObj(ci, attr)

          idx := (screenY * w + screenX) * 4
          fb[idx]     = shade
          fb[idx + 1] = shade
          fb[idx + 2] = shade
          fb[idx + 3] = 255
        :e
      :e
    :e
  :e


  // VRAM debug renderer: ไม่สน LCDC / BGP / SCX/SCY ก่อน
  // อ่าน BG map 0x9800 + tile data 0x8000 → ใช้ colorIndex เป็น shade ตรง ๆ
  // --- BG + Window renderer (DMG-style) -----------------------
  :m renderBG()
    mem := :@mem
    fb  := :@frameBuffer
    w   := :@width
    h   := :@height

    if (!mem || !fb) -> :^

    // --- อ่านรีจิสเตอร์จอ ---
    lcdc := mem.rb(0xFF40) & 0xFF
    scy  := mem.rb(0xFF42) & 0xFF
    scx  := mem.rb(0xFF43) & 0xFF
    wy   := mem.rb(0xFF4A) & 0xFF
    wx   := mem.rb(0xFF4B) & 0xFF
    bgp  := mem.rb(0xFF47) & 0xFF

    // bit flags
    lcdOn     := (lcdc & 0x80) != 0      // ตอนนี้ยังไม่ใช้ปิดจอจริง ๆ
    winMapSel := (lcdc & 0x40) != 0
    winEnable := (lcdc & 0x20) != 0
    tileSel   := (lcdc & 0x10) != 0      // 1 = 0x8000 (unsigned), 0 = 0x8800 (signed, base=0x9000)
    bgMapSel  := (lcdc & 0x08) != 0
	
	// DEBUG: ปิด window ทิ้งทั้งจอ เพื่อตรวจ BG เพียว ๆ
    //winEnable = :(
    // bit2 sprite size ไม่ใช้ที่นี่
    // bit1 sprite enable ไม่ใช้ที่นี่
    bgEnable  := (lcdc & 0x01) != 0

    bgMapBase  := bgMapSel  ? 0x9C00 : 0x9800
    winMapBase := winMapSel ? 0x9C00 : 0x9800

    tileDataBase := tileSel ? 0x8000 : 0x9000
    signedIndex  := !tileSel   // โหมด 0x8800 ใช้ signed index

	// --- แปลง BGP (2-bit per color) → shade 0..255 ---
	fn shadeFromPal(idx)
	  bits := (bgp >> (idx * 2)) & 0x03

	  // ใช้ if/else แทน switch (:~) เพราะ :~ ใน compiler ตอนนี้ยังไม่มี break
	  if (bits == 0)
		:^ 255    // 00 = ขาว
	  :? if (bits == 1)
		:^ 192    // 01
	  :? if (bits == 2)
		:^ 96     // 10
	  :e
		:^ 0      // 11 = ดำ
	:e



    shade0 := shadeFromPal(0)
    shade1 := shadeFromPal(1)
    shade2 := shadeFromPal(2)
    shade3 := shadeFromPal(3)

    // ถ้า BG+Window ปิดหมด → เคลียร์ด้วยสี index0 ไปเลย
    if (!bgEnable && !winEnable)
      size := w * h
      :* (let i = 0; i < size; i++)
        idx := i * 4
        fb[idx]     = shade0
        fb[idx + 1] = shade0
        fb[idx + 2] = shade0
        fb[idx + 3] = 255
      :e
      :^
    :e

    winStartX := (wx - 7) & 0xFF   // ตำแหน่งซ้ายของ window บนจอ

    :* (let y = 0; y < h; y++)
      bgY := (scy + y) & 0xFF

      :* (let x = 0; x < w; x++)
        useWin := :(
        tX := 0
        tY := 0
        tileMapBase := bgMapBase

        // --- เลือกใช้ Window หรือ BG ---
        if (winEnable && wy <= 143)
          if (y >= wy)
            if (winStartX <= 159 && x >= winStartX)
              winY := y - wy
              winX := x - winStartX
              if (winX >= 0 && winX < 160 && winY >= 0 && winY < 144)
                useWin = :)
                tX = winX
                tY = winY
                tileMapBase = winMapBase
              :e
            :e
          :e
        :e

        if (!useWin)
          bgX := (scx + x) & 0xFF
          tX = bgX
          tY = bgY
          tileMapBase = bgMapBase
        :e

        tileRow := (tY >> 3) & 31
        tileCol := (tX >> 3) & 31
        mapIndex := (tileRow << 5) + tileCol

        tIndex := mem.rb(tileMapBase + mapIndex) & 0xFF

        // --- แปลง tile index → tile address (รองรับโหมด signed) ---
        tileAddr := 0
        if (signedIndex)
          // sign-extend 8-bit → 32-bit
          si := (tIndex << 24) >> 24
          tileAddr = (tileDataBase + si * 16) & 0xFFFF
        :e
        if (!signedIndex)
          tileAddr = (tileDataBase + tIndex * 16) & 0xFFFF
        :e

        fineY := tY & 7
        fineX := 7 - (tX & 7)   // bit 7..0 ซ้าย→ขวา

        low  := mem.rb(tileAddr + fineY * 2)
        high := mem.rb(tileAddr + fineY * 2 + 1)

        bit  := (low  >> fineX) & 1
        bit2 := (high >> fineX) & 1
		
        colorIndex := (bit2 << 1) | bit   // 0..3

        shade := shade0
        if (colorIndex == 1)
          shade = shade1
        :? if (colorIndex == 2)
          shade = shade2
        :? if (colorIndex == 3)
          shade = shade3
        :e

        idx := (y * w + x) * 4
        fb[idx]     = shade
        fb[idx + 1] = shade
        fb[idx + 2] = shade
        fb[idx + 3] = 255

      :e
    :e
  :e








  // XOR plasma test pattern เดิม ใช้ fallback เวลา LCD ไม่ on
  :m renderTestPattern()
    fb := :@frameBuffer
    w  := :@width
    h  := :@height

    t := :@frameCount & 0xFF
    :@frameCount++

    size := w * h
    :* (let i = 0; i < size; i++)
      x := i % w
      y := (i / w) | 0

      v := (x ^ y ^ t) & 0xFF

      j := i * 4
      fb[j]     = v
      fb[j + 1] = v
      fb[j + 2] = v
      fb[j + 3] = 255
    :e
  :e
:e







:c GBWebGLRenderer
  :n (canvasId, w, h, scale)
    :@canvas := document.getElementById(canvasId)
    if (!:@canvas) -> :^

    :@width  := w  || GB_SCREEN_W
    :@height := h  || GB_SCREEN_H
    :@scale  := scale || GB_SCALE

    :@canvas.width  = :@width  * :@scale
    :@canvas.height = :@height * :@scale

    :@gl := :@canvas.getContext("webgl")
    if (!:@gl) -> :^

    :@initProgram()
    :@initBuffers()
    :@initTexture()
  :e

  :m initProgram()
    gl := :@gl

    vsSource :: `
      attribute vec2 a_position;
      attribute vec2 a_texCoord;
      varying vec2 v_texCoord;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texCoord = a_texCoord;
      }
    `

    fsSource :: `
      precision mediump float;
      varying vec2 v_texCoord;
      uniform sampler2D u_texture;
      void main() {
        gl_FragColor = texture2D(u_texture, v_texCoord);
      }
    `

    vs := :@createShader(gl.VERTEX_SHADER, vsSource)
    fs := :@createShader(gl.FRAGMENT_SHADER, fsSource)

    prog := gl.createProgram()
    gl.attachShader(prog, vs)
    gl.attachShader(prog, fs)
    gl.linkProgram(prog)

    if (!gl.getProgramParameter(prog, gl.LINK_STATUS))
      console.error("Program link failed:", gl.getProgramInfoLog(prog))
      :^
    :e

    :@program = prog
    gl.useProgram(prog)

    :@aPosition := gl.getAttribLocation(prog, "a_position")
    :@aTexCoord := gl.getAttribLocation(prog, "a_texCoord")
    :@uTexture  := gl.getUniformLocation(prog, "u_texture")
	
	if (:@uTexture)
      gl.useProgram(prog)
      gl.uniform1i(:@uTexture, 0)
    :e

  :e

  :m createShader(type, source)
    gl := :@gl
    sh := gl.createShader(type)
    gl.shaderSource(sh, source)
    gl.compileShader(sh)
    if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS))
      console.error("Shader compile failed:", gl.getShaderInfoLog(sh))
      :^ :$
    :e
    :^ sh
  :e

    :m initBuffers()
    gl := :@gl

    // fullscreen quad
    verts := :N Float32Array([
      -1, -1,   0, 1,
       1, -1,   1, 1,
      -1,  1,   0, 0,
       1,  1,   1, 0,
    ])

    buf := gl.createBuffer()
    :@vbo = buf

    gl.bindBuffer(gl.ARRAY_BUFFER, buf)
    gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW)

    stride := 4 * 4

    gl.enableVertexAttribArray(:@aPosition)
    gl.vertexAttribPointer(:@aPosition, 2, gl.FLOAT, :(, stride, 0)

    gl.enableVertexAttribArray(:@aTexCoord)
    gl.vertexAttribPointer(:@aTexCoord, 2, gl.FLOAT, :(, stride, 8)
  :e


  :m initTexture()
    gl := :@gl
    tex := gl.createTexture()
    :@texture = tex

    gl.bindTexture(gl.TEXTURE_2D, tex)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
  :e

    :m draw(frameBuffer)
    gl := :@gl
    if (!gl || !:@texture || !frameBuffer) -> :^

    // เผื่อบางบราวเซอร์ state แปลก → bind ทุกครั้งให้ชัวร์
    gl.viewport(0, 0, :@canvas.width, :@canvas.height)

    gl.useProgram(:@program)

    if (:@vbo)
      gl.bindBuffer(gl.ARRAY_BUFFER, :@vbo)
      stride := 4 * 4
      gl.enableVertexAttribArray(:@aPosition)
      gl.vertexAttribPointer(:@aPosition, 2, gl.FLOAT, :(, stride, 0)

      gl.enableVertexAttribArray(:@aTexCoord)
      gl.vertexAttribPointer(:@aTexCoord, 2, gl.FLOAT, :(, stride, 8)
    :e

    gl.activeTexture(gl.TEXTURE0)
    gl.bindTexture(gl.TEXTURE_2D, :@texture)

    w := GB_SCREEN_W
    h := GB_SCREEN_H

    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      gl.RGBA,
      w,
      h,
      0,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      frameBuffer
    )

    gl.clearColor(0, 0, 0, 1)
    gl.clear(gl.COLOR_BUFFER_BIT)

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)

    err := gl.getError()
    if (err != gl.NO_ERROR)
      console.error("WebGL draw error:", err)
    :e
  :e

:e

:c GBEmu
  :n (canvasId)
    :@mem := :N GBMemory()
    :@ppu := :N GBPPU()
    :@ppu.attachMemory(:@mem)
    :@cpu := :N GBCPU(:@mem, :@ppu)

    :@apu := :N GBAPU(:@mem)
    :@mem.attachCpu(:@cpu)
    :@mem.attachApu(:@apu)

    :@renderer := :N GBWebGLRenderer(canvasId, GB_SCREEN_W, GB_SCREEN_H, GB_SCALE)


    // initial basic state (RAM/IO + PPU)
    :@mem.reset()
    :@ppu.reset()

    // PPU timing (approx)
    :@ppuScanlineCycles := 0
    :@ppuLY := 0
    :@mem.wb(0xFF44, 0)  // LY register เริ่มที่ 0
	
    // --- Timer state ---
    :@divCounter   := 0    // internal 16-bit counter
    :@divHighCache := 0    // last written FF04
    :@timerCounter := 0    // accumulate cycles for TIMA

    :@running := :(
    :@lastTime := 0
    :@boundFrameLoop := (t) => :@frameLoop(t)
	
	 // debug frame log
    :@frameDebug := :(
    :@frameNo := 0
  :e
  
    // เติม tile ปลอม ๆ ลง VRAM 0x8000 เพื่อเทสต์ renderBG โดยไม่พึ่งเกม
  :m debugFillTestTiles()
    mem := :@mem
    tileBase := 0x8000
    tileCount := 256     // ยัด 256 tile แรกให้หมดไปเลย

    :* (let t = 0; t < tileCount; t++)
      :* (let row = 0; row < 8; row++)
        pattern := ((t << 3) + row) & 0xFF
        addr := tileBase + t * 16 + row * 2
        mem.wb(addr,     pattern)
        mem.wb(addr + 1, (~pattern) & 0xFF)
      :e
    :e
  :e

  :m debugForceBGTest()
    // หยุด main loop ก่อน กันไม่ให้ frameLoop มาทับผลเรา
    :@running = :(

    mem := :@mem

    // 1) ยัด tile ปลอม ๆ ลง 0x8000– ให้ครบช่วง
    :@debugFillTestTiles()

    // 2) fill BG map 0x9800 ด้วย tile index ไล่ ๆ กันให้เห็นลาย
    :* (let i = 0; i < 32 * 32; i++)
      mem.wb(0x9800 + i, i & 0xFF)
    :e

    // 3) บังคับค่า register จอแบบง่ายสุด
    // LCDC = 0x91: LCD on, BG on, tile data = 0x8000 (unsigned), BG map = 0x9800
    mem.wb(0xFF40, 0x91)
    mem.wb(0xFF42, 0)    // SCY
    mem.wb(0xFF43, 0)    // SCX
    mem.wb(0xFF47, 0xE4) // BGP

    // 4) วาด BG ลง framebuffer แล้วส่งเข้า WebGL
    :@ppu.renderBG()
	:@ppu.renderSprites()   
    :@renderer.draw(:@ppu.frameBuffer)
  :e


  :m debugDumpState()
    pc := :@cpu.pc
    bg0 := :@mem.rb(0x9800)   // BG map ช่องแรก
    t0  := :@mem.rb(0x8000)   // byte แรกของ tile data
    ly  := :@mem.rb(0xFF44)
    lcdc := :@mem.rb(0xFF40)
    bgp  := :@mem.rb(0xFF47)

    pcHex := pc.toString(16)

    console.log(
      "PC=0x" + pcHex,
      " BG[0]=", bg0,
      " Tile0=", t0,
      " LY=", ly,
      " LCDC=0x" + lcdc.toString(16),
      " BGP=0x" + bgp.toString(16)
    )
  :e

    // วาด tile data จาก 0x8000 เป็น grid ลง canvas 2D
    // วาด VRAM tile 0x8000.. เป็น grid ลง canvas2D
    :m debugDrawVramTiles(canvasId)
    mem := :@mem
    canvas := document.getElementById(canvasId)
    if (!canvas) -> :^
    ctx := canvas.getContext("2d")

    tileSize := 8
    tilesPerRow := 16

    canvas.width  = tilesPerRow * tileSize
    canvas.height = tilesPerRow * tileSize

    :* (let t = 0; t < 256; t++)
      baseX := (t % tilesPerRow) * tileSize
      baseY := ((t / tilesPerRow) | 0) * tileSize
      tileAddr := 0x8000 + t * 16

      :* (let row = 0; row < 8; row++)
        low  := mem.rb(tileAddr + row * 2)
        high := mem.rb(tileAddr + row * 2 + 1)

        :* (let col = 0; col < 8; col++)
          bit  := (low  >> (7 - col)) & 1
          bit2 := (high >> (7 - col)) & 1
          ci := (bit2 << 1) | bit   // 0..3
          shade := ci * 85          // ไม่สน BGP

          ctx.fillStyle = `rgb(${shade},${shade},${shade})`
          ctx.fillRect(baseX + col, baseY + row, 1, 1)
        :e
      :e
    :e
  :e



   :m debugDrawPalettes(canvasId)
    mem := :@mem
    canvas := document.getElementById(canvasId)
    if (!canvas || !mem) -> :^

    ctx := canvas.getContext("2d")
    w := canvas.width
    h := canvas.height

    // ล้างพื้นหลังดำ
    ctx.fillStyle = "rgb(0,0,0)"
    ctx.fillRect(0, 0, w, h)

    // helper: map 2-bit → shade 0..255 (0 = ขาว, 3 = ดำ)
    fn shadeFromBits(bits)
      shade := 0
      :~ bits
        :! 0 
          shade = 255
		  :/
        :! 1 
          shade = 192
		  :/
        :! 2 
          shade = 96
		  :/
        :! 3 
          shade = 0
		  :/
        :_ 
          shade = 0
      :e
      :^ shade
    :e

    boxW := 40
    boxH := 20
    baseX := 10
    baseY := 10

    // palIndex: 0 = BGP, 1 = OBP0, 2 = OBP1
    :* (let palIndex = 0; palIndex < 3; palIndex++)
      pal := 0
      :~ palIndex
        :! 0 
          pal = mem.rb(0xFF47)   // BGP
		  :/
        :! 1 
          pal = mem.rb(0xFF48)   // OBP0
		  :/
        :! 2 
          pal = mem.rb(0xFF49)   // OBP1
		  :/
        :_ 
          pal = 0
      :e

      y0 := baseY + palIndex * (boxH + 8)

      // ช่องสีใน palette (0..3)
      :* (let colorIdx = 0; colorIdx < 4; colorIdx++)
        bits := (pal >> (colorIdx * 2)) & 0x03
        shade := shadeFromBits(bits)

        x0 := baseX + colorIdx * (boxW + 8)
        ctx.fillStyle = `rgb(${shade},${shade},${shade})`
        ctx.fillRect(x0, y0, boxW, boxH)
      :e
    :e
  :e


  :m tickApu(cycles)
    if (:@apu)
      :@apu.tick(cycles)
    :e
  :e


  // cycles = CPU cycles ที่เพิ่งใช้ไป
  :m tickTimers(cycles)
    mem := :@mem

    // --- DIV (0xFF04) ---
    // ถ้าโค้ดฝั่ง CPU เขียนค่าอื่นใส่ FF04 → treat เป็น reset
    divReg := mem.rb(0xFF04)
    if (divReg != :@divHighCache)
      // user write → reset system counter
      :@divCounter   = 0
      :@divHighCache = 0
      mem.wb(0xFF04, 0)
    :e

    // เพิ่ม internal counter ตาม cycles
    div := (:@divCounter + cycles) & 0xFFFF
    :@divCounter = div

    newHigh := (div >> 8) & 0xFF
    if (newHigh != :@divHighCache)
      :@divHighCache = newHigh
      mem.wb(0xFF04, newHigh)
    :e

    // --- TIMA/TMA/TAC ---
    tac := mem.rb(0xFF07)
    if (tac & 0x04)      // bit2: timer enable
      freqSel := tac & 0x03
	  tickCycles := 1024   // 00: 4096 Hz
      // จำนวน CPU cycles ต่อ 1 tick ของ TIMA (approx)
      if (freqSel == 1)    // 01: 262144 Hz
        tickCycles = 16 
      :? if (freqSel == 2) // 10: 65536 Hz
        tickCycles = 64 
      :? if (freqSel == 3) // 11: 16384 Hz
        tickCycles = 256 
      :e

      acc := :@timerCounter + cycles
      // อาจ tick ทีละหลายครั้งได้ ถ้า cycles เยอะ
      :w (acc >= tickCycles)
        acc -= tickCycles
        tima := (mem.rb(0xFF05) + 1) & 0xFF
        if (tima == 0)
          // overflow → reload TMA + ขอ interrupt
          tma := mem.rb(0xFF06)
          mem.wb(0xFF05, tma)

          ifreg := mem.rb(0xFF0F) | 0x04   // bit2 = TIMA
          mem.wb(0xFF0F, ifreg)
        else
          mem.wb(0xFF05, tima)
        :e
      :e

      :@timerCounter = acc
    :e
  :e


  :m tickPpu(cycles)
    mem := :@mem
    ly  := :@ppuLY
    acc := :@ppuScanlineCycles

    acc = (acc + cycles) | 0

    // 1 scanline ≈ 456 cycles
    :w (acc >= 456)
      acc = acc - 456

      ly = (ly + 1) & 0xFF
      if (ly >= 154)
        ly = 0
      :e

      // อัปเดต LY register ให้ CPU อ่านได้
      mem.wb(0xFF44, ly)

      // เข้า VBlank ช่วง LY = 144..153
      if (ly == 144)
        curIF := mem.rb(0xFF0F)
        mem.wb(0xFF0F, curIF | 0x01)   // set VBlank bit
      :e
    :e

    :@ppuScanlineCycles = acc
    :@ppuLY = ly
  :e


  :m loadRomFromArrayBuffer(buf)
    rom := :N Uint8Array(buf)

    // reset RAM + IO, แล้วค่อยโหลด ROM + reset CPU/PPU
    :@mem.reset()
    :@mem.loadRom(rom)
    :@cpu.reset()
    :@ppu.reset()
    if (:@apu)
      :@apu.reset()
    :e

    // debug: log header บางส่วนให้เช็คว่า ROM โหลดจริง
    if (typeof console !== "undefined" && console && console.log)
      t0 := :@mem.rb(0x0104)
      t1 := :@mem.rb(0x0105)
      t2 := :@mem.rb(0x0106)
      t3 := :@mem.rb(0x0107)
      console.log("ROM header @0104:", t0, t1, t2, t3)
    :e
  :e

  :m loadRomFromUrl(url)
    // Fetch ROM (.gb) แล้วโหลดเข้า memory
    :^ fetch(url)
      .then((res) => res.arrayBuffer())
      .then((buf) => {
        :@loadRomFromArrayBuffer(buf)
        :^ this
      })
  :e

  :m start()
    if (!:@renderer || !:@renderer.gl) -> :^

    :@running = :)
    :@lastTime = performance.now()
    requestAnimationFrame(:@boundFrameLoop)
  :e





  :m stop()
    :@running = :(
  :e
  
  :m pause()
    :@running = :(
  :e
  
  :m resume()
    :@running = :)
  :e
  
  :m resumeAudio()
    if (:@apu)
      :@apu.resume()
    :e
  :e


  :m debugRenderTestOnce()
    // หยุด loop ก่อนกันโดนทับ
    :@running = :(
    :@ppu.renderTestPattern()
    :@renderer.draw(:@ppu.frameBuffer)
  :e



    :m frameLoop(now)
    if (!:@running) -> :^

    dtMs := now - :@lastTime
    if (dtMs < 0) dtMs = 0
    :@lastTime = now
    if (dtMs > 50) dtMs = 50

    cyclesPerMs := GB_CPU_HZ / 1000
    target := (dtMs * cyclesPerMs) | 0
    if (target < 0) target = 0

    :@runCpu(target)

    // วาด BG จาก VRAM → framebuffer → WebGL
    :@ppu.renderBG()
    :@renderer.draw(:@ppu.frameBuffer)

    requestAnimationFrame(:@boundFrameLoop)
  :e



  :m runCpu(totalCycles)
    spent := 0
    :* ( ; spent < totalCycles; )
      step := :@cpu.step()
      if (step <= 0) step = 4   // safety เผื่ออนาคต

      spent += step

      // tick timer + PPU + APU ทุก instruction
      :@tickTimers(step)
      :@tickPpu(step)
      :@tickApu(step)
    :e

    :@ppu.renderBG()
    :@renderer.draw(:@ppu.frameBuffer)



        // วาดเฟรมหลังจบ CPU chunk
    :@ppu.renderBG()
    :@renderer.draw(:@ppu.frameBuffer)

    // debug Tetris demo
    if (:@frameDebug)
      :@frameNo = (:@frameNo + 1) | 0

      // log ทุก 64 เฟรม (จะเห็นตอนมันเปลี่ยน screen 1→2→3 ชัด)
      if ((:@frameNo & 0x3F) == 0)
        pc   := :@cpu.pc
        ly   := :@mem.rb(0xFF44)
        lcdc := :@mem.rb(0xFF40)
        bgp  := :@mem.rb(0xFF47)
        scx  := :@mem.rb(0xFF43)
        scy  := :@mem.rb(0xFF42)
        wx   := :@mem.rb(0xFF4B)
        wy   := :@mem.rb(0xFF4A)
        ie   := :@mem.rb(0xFFFF)
        iff  := :@mem.rb(0xFF0F)
        tima := :@mem.rb(0xFF05)
        tac  := :@mem.rb(0xFF07)
        div  := :@mem.rb(0xFF04)

        console.log(
          "PC=0x" + pc.toString(16),
          "LY=" + ly,
          "LCDC=0x" + lcdc.toString(16),
          "BGP=0x" + bgp.toString(16),
          "SCX=" + scx,
          "SCY=" + scy,
          "WX=" + wx,
          "WY=" + wy,
          "IE=0x" + ie.toString(16),
          "IF=0x" + iff.toString(16),
          "TIMA=" + tima,
          "TAC=0x" + tac.toString(16),
          "DIV=" + div
        )

        // ----- BG MAP SNAPSHOT รอบมุมซ้ายของจอ -----
        // ใช้ base เดียวกับ renderBG()
        bgMapBase := ((lcdc & 0x08) != 0) ? 0x9C00 : 0x9800

        baseRow := (scy >> 3) & 31   // แถว tile ใน BG map ที่ทับ Y บนของจอ
        baseCol := (scx >> 3) & 31   // คอลัมน์ tile ที่ทับ X ซ้ายของจอ
		// dump 6 แถวแรกของจอ
        :* (let r = 0; r < 6; r++)   
          mapY := (baseRow + r) & 31
          line := ""
		  // 16 tile แรกตามแนว X
          :* (let c = 0; c < 16; c++)  
            mapX := (baseCol + c) & 31
            mapIndex := mapY * 32 + mapX
            tile := :@mem.rb(bgMapBase + mapIndex) & 0xFF

            if (tile < 16)
              line += "0"
            :e
            line += tile.toString(16) + " "
          :e
          console.log("BG row", mapY, ":", line)
        :e
      :e
    :e

	
	

  :e




:e

fn createGbEmu(canvasId)
  emu := :N GBEmu(canvasId)
  :^ emu
:e

// Export to window (plain JS assignment เพื่อไม่ไปชน sugar)
if (typeof window !== "undefined")
  window.GBEmu = GBEmu
  window.createGbEmu = createGbEmu
end
