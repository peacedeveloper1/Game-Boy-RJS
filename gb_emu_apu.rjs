// Game Boy APU (very simplified) for RJS WebGL emulator
// NOTE: ไม่ cycle-accurate แต่พอให้ได้ยินเพลง (ch1/ch2/ch3/ch4)

:c GBAPU
  :n (mem)
    :@mem        := mem
    :@ctx        := :$
    :@sampleRate := 44100

    :@masterGain := :$
    :@ch1Osc     := :$
    :@ch1Gain    := :$
    :@ch2Osc     := :$
    :@ch2Gain    := :$
    :@ch3Osc     := :$
    :@ch3Gain    := :$
    :@ch4Noise   := :$
    :@ch4Gain    := :$
    :@noiseBuf   := :$

    :@enabled    := :(
    :@regs       := :N Uint8Array(0x80)   // mirror FFxx สำหรับเสียง
  :e


  // สร้าง AudioContext + oscillator แต่ยังไม่เล่นอะไร (gain = 0)
  :m ensureAudio()
    if (:@ctx) -> :^

    if (typeof window === "undefined") -> :^
    Ctor := window.AudioContext || window.webkitAudioContext
    if (!Ctor) -> :^

    ctx := :N Ctor()
    :@ctx        = ctx
    :@sampleRate = ctx.sampleRate || 44100

    master := ctx.createGain()
    // base gain เผื่อกรณีเกมไม่เขียน NR50 เราก็ยังได้ยิน
    master.gain.value = 0.3
    master.connect(ctx.destination)
    :@masterGain = master

    // --- Channel 1 : square ---
    ch1Osc  := ctx.createOscillator()
    ch1Gain := ctx.createGain()
    ch1Osc.type = "square"
    ch1Osc.frequency.value = 440   // placeholder, จะถูก override จาก regs
    ch1Gain.gain.value = 0        // เริ่มเงียบไว้ก่อน
    ch1Osc.connect(ch1Gain)
    ch1Gain.connect(master)
    ch1Osc.start()

    :@ch1Osc  = ch1Osc
    :@ch1Gain = ch1Gain

    // --- Channel 2 : square ---
    ch2Osc  := ctx.createOscillator()
    ch2Gain := ctx.createGain()
    ch2Osc.type = "square"
    ch2Osc.frequency.value = 440
    ch2Gain.gain.value = 0
    ch2Osc.connect(ch2Gain)
    ch2Gain.connect(master)
    ch2Osc.start()

    :@ch2Osc  = ch2Osc
    :@ch2Gain = ch2Gain

    // --- Channel 3 : wave (approx triangle) ---
    ch3Osc  := ctx.createOscillator()
    ch3Gain := ctx.createGain()
    ch3Osc.type = "triangle"
    ch3Osc.frequency.value = 440
    ch3Gain.gain.value = 0
    ch3Osc.connect(ch3Gain)
    ch3Gain.connect(master)
    ch3Osc.start()

    :@ch3Osc  = ch3Osc
    :@ch3Gain = ch3Gain

    // --- Channel 4 : noise (buffer source) ---
    noiseBuf := ctx.createBuffer(1, :@sampleRate, :@sampleRate)
    data     := noiseBuf.getChannelData(0)
    :* (let i = 0; i < data.length; i++)
      data[i] = (Math.random() * 2.0) - 1.0
    :e

    noiseSrc := ctx.createBufferSource()
    noiseSrc.buffer = noiseBuf
    noiseSrc.loop   = :)
    ch4Gain  := ctx.createGain()
    ch4Gain.gain.value = 0

    noiseSrc.connect(ch4Gain)
    ch4Gain.connect(master)
    noiseSrc.start()

    :@noiseBuf = noiseBuf
    :@ch4Noise = noiseSrc
    :@ch4Gain  = ch4Gain
  :e


  // เรียกจาก user gesture (เช่น click ปุ่ม / canvas) → ปลดล็อคเสียง
  :m resume()
    :@ensureAudio()
    if (!:@ctx) -> :^

    if (:@ctx.state === "suspended")
      :@ctx.resume()
    :e

    :@enabled = :)

    // ดัน master gain ให้ดังพอสมควร (เกมยัง control vol ใน ch1/ch2 ต่อ)
    if (:@masterGain)
      :@masterGain.gain.value = 0.35
    :e

    // apply state ปัจจุบันของ regs ให้ oscillator ทันที
    :@updateCh1()
    :@updateCh2()
    :@updateCh3()
    :@updateCh4()
  :e


  :m reset()
    :@regs.fill(0)
    if (:@ch1Gain)
      :@ch1Gain.gain.value = 0
    :e
    if (:@ch2Gain)
      :@ch2Gain.gain.value = 0
    :e
    if (:@ch3Gain)
      :@ch3Gain.gain.value = 0
    :e
    if (:@ch4Gain)
      :@ch4Gain.gain.value = 0
    :e
  :e


  // addr: absolute (0xFF10..0xFF3F)
  :m writeReg(addr, val)
    off := addr & 0xFF
    v   := val & 0xFF

    // เก็บ local copy สำหรับคำนวณเสียง
    idx := off
    if (idx < 0 || idx >= :@regs.length) -> :^
    :@regs[idx] = v

    // NR52 (FF26) - global sound enable
    if (off == 0x26)
      :@enabled = (v & 0x80) != 0
      if (!:@enabled)
        if (:@ch1Gain)
          :@ch1Gain.gain.value = 0
        :e
        if (:@ch2Gain)
          :@ch2Gain.gain.value = 0
        :e
        if (:@ch3Gain)
          :@ch3Gain.gain.value = 0
        :e
        if (:@ch4Gain)
          :@ch4Gain.gain.value = 0
        :e
      :e
      :^
    :e

    // NR50 (FF24) - master volume
    if (off == 0x24)
      :@updateMaster()
      :^
    :e

    // ch1: NR11..NR14 (FF11..FF14)
    if (off >= 0x11 && off <= 0x14)
      :@updateCh1()
      :^
    :e

    // ch2: NR21..NR24 (FF16..FF19)
    if (off >= 0x16 && off <= 0x19)
      :@updateCh2()
      :^
    :e

    // ch3: NR30..NR34 (FF1A..FF1E) + wave RAM (FF30..FF3F)
    if ((off >= 0x1A && off <= 0x1E) || (off >= 0x30 && off <= 0x3F))
      :@updateCh3()
      :^
    :e

    // ch4: NR41..NR44 (FF20..FF23)
    if (off >= 0x20 && off <= 0x23)
      :@updateCh4()
      :^
    :e
  :e


  :m updateMaster()
    if (!:@ctx || !:@masterGain) -> :^

    nr50 := :@regs[0x24]
    left  := (nr50 >> 4) & 0x7
    right := nr50 & 0x7
    volBits := left
    if (right > volBits) volBits = right

    // ถ้าเกมไม่ตั้ง NR50 เลย → ให้มีเสียง baseline 0.35
    gain := 0.35
    if (volBits > 0)
      gain = (volBits / 7.0) * 0.4
    :e

    :@masterGain.gain.value = gain
  :e


  :m updateCh1()
    // ไม่ auto สร้าง AudioContext ตรงนี้แล้ว ต้องให้ resume() ทำเท่านั้น
    if (!:@ctx || !:@ch1Osc || !:@ch1Gain) -> :^
    if (!:@enabled)
      :@ch1Gain.gain.value = 0
      :^
    :e

    nr12 := :@regs[0x12]
    nr13 := :@regs[0x13]
    nr14 := :@regs[0x14]

    // volume จาก NR12 [7:4]
    vol := (nr12 >> 4) & 0xF
    if (vol == 0)
      :@ch1Gain.gain.value = 0
      :^
    :e

    // freq (11-bit) จาก NR13 + NR14[2:0]
    freq := 0
    raw  := ((nr14 & 0x07) << 8) | nr13

    if (raw >= 2048)
      freq = 0
    :?
      // DMG formula: 131072 / (2048 - raw)
      freq = 131072.0 / (2048.0 - raw)
    :e

    if (freq <= 0)
      :@ch1Gain.gain.value = 0
      :^
    :e

    amp := (vol / 15.0) * 0.35
    now := :@ctx.currentTime || 0

    :@ch1Osc.frequency.setTargetAtTime(freq, now, 0.002)
    :@ch1Gain.gain.setTargetAtTime(amp,  now, 0.01)
  :e


  :m updateCh2()
    if (!:@ctx || !:@ch2Osc || !:@ch2Gain) -> :^
    if (!:@enabled)
      :@ch2Gain.gain.value = 0
      :^
    :e

    nr22 := :@regs[0x17]
    nr23 := :@regs[0x18]
    nr24 := :@regs[0x19]

    vol := (nr22 >> 4) & 0xF
    if (vol == 0)
      :@ch2Gain.gain.value = 0
      :^
    :e

    raw  := ((nr24 & 0x07) << 8) | nr23
    freq := 0

    if (raw >= 2048)
      freq = 0
    :?
      freq = 131072.0 / (2048.0 - raw)
    :e

    if (freq <= 0)
      :@ch2Gain.gain.value = 0
      :^
    :e

    amp := (vol / 15.0) * 0.35
    now := :@ctx.currentTime || 0

    :@ch2Osc.frequency.setTargetAtTime(freq, now, 0.002)
    :@ch2Gain.gain.setTargetAtTime(amp,  now, 0.01)
  :e


  :m updateCh3()
    if (!:@ctx || !:@ch3Osc || !:@ch3Gain) -> :^
    if (!:@enabled)
      :@ch3Gain.gain.value = 0
      :^
    :e

    // NR30: DAC power (bit7)
    nr30 := :@regs[0x1A]
    if ((nr30 & 0x80) == 0)
      :@ch3Gain.gain.value = 0
      :^
    :e

    nr32 := :@regs[0x1C]
    nr33 := :@regs[0x1D]
    nr34 := :@regs[0x1E]

    // volume code bits [6:5]: 0=0%, 1=100%, 2=50%, 3=25%
    volCode := (nr32 >> 5) & 0x3
    scale   := 0.0

    if (volCode == 0)
      scale = 0.0
    :?
      :~ volCode
        :! 1 scale = 1.0
        :! 2 scale = 0.5
        :! 3 scale = 0.25
      :e
    :e

    if (scale <= 0.0)
      :@ch3Gain.gain.value = 0
      :^
    :e

    raw  := ((nr34 & 0x07) << 8) | nr33
    freq := 0.0

    if (raw >= 2048)
      freq = 0.0
    :?
      freq = 131072.0 / (2048.0 - raw)
    :e

    if (freq <= 0.0)
      :@ch3Gain.gain.value = 0
      :^
    :e

    amp := scale * 0.35
    now := :@ctx.currentTime || 0

    :@ch3Osc.frequency.setTargetAtTime(freq, now, 0.002)
    :@ch3Gain.gain.setTargetAtTime(amp,  now, 0.01)
  :e


  :m updateCh4()
    if (!:@ctx || !:@ch4Noise || !:@ch4Gain) -> :^
    if (!:@enabled)
      :@ch4Gain.gain.value = 0
      :^
    :e

    nr42 := :@regs[0x21]
    nr43 := :@regs[0x22]
    nr44 := :@regs[0x23]

    vol := (nr42 >> 4) & 0xF
    if (vol == 0)
      :@ch4Gain.gain.value = 0
      :^
    :e

    amp := (vol / 15.0) * 0.35

    divCode := nr43 & 0x7
    shift   := (nr43 >> 4) & 0xF

    baseDiv := 0.5
    :~ divCode
      :! 0 baseDiv = 0.5
      :! 1 baseDiv = 1.0
      :! 2 baseDiv = 2.0
      :! 3 baseDiv = 4.0
      :! 4 baseDiv = 6.0
      :! 5 baseDiv = 8.0
      :! 6 baseDiv = 10.0
      :! 7 baseDiv = 12.0
    :e

    period := baseDiv * (1 << shift)
    rate   := 1.0 / period

    if (rate < 0.01) rate = 0.01
    if (rate > 8.0)  rate = 8.0

    now := :@ctx.currentTime || 0

    :@ch4Noise.playbackRate.setTargetAtTime(rate, now, 0.01)
    :@ch4Gain.gain.setTargetAtTime(amp,      now, 0.01)
  :e


  // ไว้ต่ออนาคต: length / envelope frame sequencer
  :m tick(cycles)
    // TODO: implement length/envelope frame sequencer (256Hz/64Hz)
  :e
:e

export GBAPU
