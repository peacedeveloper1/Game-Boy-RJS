// Game Boy APU (very simplified) for RJS WebGL emulator
/*!
 * © Peacedeveloper. All rights reserved.
 * https://peacedeveloper1.github.io/
 * peacedeveloper@gmail.com
 * Unauthorized copying, modification, or distribution is prohibited.
 */
:c GBAPU
  :n (mem)
    :@mem        := mem
    :@ctx        := :$
    :@sampleRate := 44100

    :@masterGain := :$
    :@ch1Osc     := :$
    :@ch1Gain    := :$
    :@ch2Osc     := :$
    :@ch2Gain    := :$

    :@enabled    := :(
    :@regs       := :N Uint8Array(0x80)   // mirror FFxx สำหรับเสียง
  :e


  // สร้าง AudioContext + oscillator แต่ยังไม่เล่นอะไร (gain = 0)
  :m ensureAudio()
    if (:@ctx) -> :^

    if (typeof window === "undefined") -> :^
    Ctor := window.AudioContext || window.webkitAudioContext
    if (!Ctor) -> :^

    ctx := :N Ctor()
    :@ctx        = ctx
    :@sampleRate = ctx.sampleRate || 44100

    master := ctx.createGain()
    // base gain เผื่อกรณีเกมไม่เขียน NR50 เราก็ยังได้ยิน
    master.gain.value = 0.3
    master.connect(ctx.destination)
    :@masterGain = master

    // --- Channel 1 : square ---
    ch1Osc  := ctx.createOscillator()
    ch1Gain := ctx.createGain()
    ch1Osc.type = "square"
    ch1Osc.frequency.value = 440   // placeholder, จะถูก override จาก regs
    ch1Gain.gain.value = 0        // เริ่มเงียบไว้ก่อน
    ch1Osc.connect(ch1Gain)
    ch1Gain.connect(master)
    ch1Osc.start()

    :@ch1Osc  = ch1Osc
    :@ch1Gain = ch1Gain

    // --- Channel 2 : square ---
    ch2Osc  := ctx.createOscillator()
    ch2Gain := ctx.createGain()
    ch2Osc.type = "square"
    ch2Osc.frequency.value = 440
    ch2Gain.gain.value = 0
    ch2Osc.connect(ch2Gain)
    ch2Gain.connect(master)
    ch2Osc.start()

    :@ch2Osc  = ch2Osc
    :@ch2Gain = ch2Gain
  :e


  // เรียกจาก user gesture (เช่น click ปุ่ม / canvas) → ปลดล็อคเสียง
  :m resume()
    :@ensureAudio()
    if (!:@ctx) -> :^

    if (:@ctx.state === "suspended")
      :@ctx.resume()
    :e

    :@enabled = :)

    // ดัน master gain ให้ดังพอสมควร (เกมยัง control vol ใน ch1/ch2 ต่อ)
    if (:@masterGain)
      :@masterGain.gain.value = 0.35
    :e

    // apply state ปัจจุบันของ regs ให้ oscillator ทันที
    :@updateCh1()
    :@updateCh2()
  :e


  :m reset()
    :@regs.fill(0)
    if (:@ch1Gain)
      :@ch1Gain.gain.value = 0
    :e
    if (:@ch2Gain)
      :@ch2Gain.gain.value = 0
    :e
  :e


  // addr: absolute (0xFF10..0xFF3F)
  :m writeReg(addr, val)
    off := addr & 0xFF
    v   := val & 0xFF

    // เก็บ local copy สำหรับคำนวณเสียง
    idx := off
    if (idx < 0 || idx >= :@regs.length) -> :^
    :@regs[idx] = v

    // NR52 (FF26) - global sound enable
    if (off == 0x26)
      :@enabled = (v & 0x80) != 0
      if (!:@enabled)
        if (:@ch1Gain)
          :@ch1Gain.gain.value = 0
        :e
        if (:@ch2Gain)
          :@ch2Gain.gain.value = 0
        :e
      :e
      :^
    :e

    // NR50 (FF24) - master volume
    if (off == 0x24)
      :@updateMaster()
      :^
    :e

    // ch1: NR11..NR14 (FF11..FF14)
    if (off >= 0x11 && off <= 0x14)
      :@updateCh1()
      :^
    :e

    // ch2: NR21..NR24 (FF16..FF19)
    if (off >= 0x16 && off <= 0x19)
      :@updateCh2()
      :^
    :e
  :e


  :m updateMaster()
    if (!:@ctx || !:@masterGain) -> :^

    nr50 := :@regs[0x24]
    left  := (nr50 >> 4) & 0x7
    right := nr50 & 0x7
    volBits := left
    if (right > volBits) volBits = right

    // ถ้าเกมไม่ตั้ง NR50 เลย → ให้มีเสียง baseline 0.35
    gain := 0.35
    if (volBits > 0)
      gain = (volBits / 7.0) * 0.4
    :e

    :@masterGain.gain.value = gain
  :e


  :m updateCh1()
    // ไม่ auto สร้าง AudioContext ตรงนี้แล้ว ต้องให้ resume() ทำเท่านั้น
    if (!:@ctx || !:@ch1Osc || !:@ch1Gain) -> :^
    if (!:@enabled)
      :@ch1Gain.gain.value = 0
      :^
    :e

    nr12 := :@regs[0x12]
    nr13 := :@regs[0x13]
    nr14 := :@regs[0x14]

    // volume จาก NR12 [7:4]
    vol := (nr12 >> 4) & 0xF
    if (vol == 0)
      :@ch1Gain.gain.value = 0
      :^
    :e

    // freq (11-bit) จาก NR13 + NR14[2:0]
    freq := 0
    raw  := ((nr14 & 0x07) << 8) | nr13

    if (raw >= 2048)
      freq = 0
    :?
      // DMG formula: 131072 / (2048 - raw)
      freq = 131072.0 / (2048.0 - raw)
    :e

    if (freq <= 0)
      :@ch1Gain.gain.value = 0
      :^
    :e

    amp := (vol / 15.0) * 0.35
    now := :@ctx.currentTime || 0

    :@ch1Osc.frequency.setTargetAtTime(freq, now, 0.002)
    :@ch1Gain.gain.setTargetAtTime(amp,  now, 0.01)
  :e


  :m updateCh2()
    if (!:@ctx || !:@ch2Osc || !:@ch2Gain) -> :^
    if (!:@enabled)
      :@ch2Gain.gain.value = 0
      :^
    :e

    nr22 := :@regs[0x17]
    nr23 := :@regs[0x18]
    nr24 := :@regs[0x19]

    vol := (nr22 >> 4) & 0xF
    if (vol == 0)
      :@ch2Gain.gain.value = 0
      :^
    :e

    raw  := ((nr24 & 0x07) << 8) | nr23
    freq := 0

    if (raw >= 2048)
      freq = 0
    :?
      freq = 131072.0 / (2048.0 - raw)
    :e

    if (freq <= 0)
      :@ch2Gain.gain.value = 0
      :^
    :e

    amp := (vol / 15.0) * 0.35
    now := :@ctx.currentTime || 0

    :@ch2Osc.frequency.setTargetAtTime(freq, now, 0.002)
    :@ch2Gain.gain.setTargetAtTime(amp,  now, 0.01)
  :e


  // ไว้ต่ออนาคต: length / envelope frame sequencer
  :m tick(cycles)
    // TODO: implement length/envelope frame sequencer (256Hz/64Hz)
  :e
:e

export GBAPU
